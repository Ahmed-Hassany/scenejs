<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SceneItem.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Animator.html">Animator</a><ul class='methods'><li data-type='method' class="method "><a href="Animator.html#end">end</a></li><li data-type='method' class="method inherits"><a href="Animator.html#hasOn">hasOn</a></li><li data-type='method' class="method inherits"><a href="Animator.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Animator.html#on">on</a></li><li data-type='method' class="method "><a href="Animator.html#pause">pause</a></li><li data-type='method' class="method "><a href="Animator.html#play">play</a></li><li data-type='method' class="method "><a href="Animator.html#reset">reset</a></li><li data-type='method' class="method "><a href="Animator.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="Animator.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Animator.html#trigger">trigger</a></li></ul></li><li><a href="EventTrigger.html">EventTrigger</a><ul class='methods'><li data-type='method' class="method "><a href="EventTrigger.html#hasOn">hasOn</a></li><li data-type='method' class="method "><a href="EventTrigger.html#off">off</a></li><li data-type='method' class="method "><a href="EventTrigger.html#on">on</a></li><li data-type='method' class="method "><a href="EventTrigger.html#trigger">trigger</a></li></ul></li><li><a href="Frame.html">Frame</a><ul class='methods'><li data-type='method' class="method "><a href="Frame.html#clone">clone</a></li><li data-type='method' class="method inherits"><a href="Frame.html#end">end</a></li><li data-type='method' class="method "><a href="Frame.html#get">get</a></li><li data-type='method' class="method "><a href="Frame.html#has">has</a></li><li data-type='method' class="method inherits"><a href="Frame.html#hasOn">hasOn</a></li><li data-type='method' class="method "><a href="Frame.html#load">load</a></li><li data-type='method' class="method "><a href="Frame.html#merge">merge</a></li><li data-type='method' class="method inherits"><a href="Frame.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Frame.html#on">on</a></li><li data-type='method' class="method inherits"><a href="Frame.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="Frame.html#play">play</a></li><li data-type='method' class="method "><a href="Frame.html#remove">remove</a></li><li data-type='method' class="method inherits"><a href="Frame.html#reset">reset</a></li><li data-type='method' class="method "><a href="Frame.html#set">set</a></li><li data-type='method' class="method inherits"><a href="Frame.html#setOptions">setOptions</a></li><li data-type='method' class="method inherits"><a href="Frame.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Frame.html#trigger">trigger</a></li></ul></li><li><a href="PropertyObject.html">PropertyObject</a><ul class='methods'><li data-type='method' class="method "><a href="PropertyObject.html#clone">clone</a></li><li data-type='method' class="method "><a href="PropertyObject.html#forEach">forEach</a></li><li data-type='method' class="method "><a href="PropertyObject.html#get">get</a></li><li data-type='method' class="method "><a href="PropertyObject.html#join">join</a></li><li data-type='method' class="method "><a href="PropertyObject.html#set">set</a></li><li data-type='method' class="method "><a href="PropertyObject.html#size">size</a></li><li data-type='method' class="method "><a href="PropertyObject.html#toValue">toValue</a></li></ul></li><li><a href="Scene.html">Scene</a><ul class='methods'><li data-type='method' class="method inherits"><a href="Scene.html#end">end</a></li><li data-type='method' class="method "><a href="Scene.html#getDuration">getDuration</a></li><li data-type='method' class="method "><a href="Scene.html#getItem">getItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#hasOn">hasOn</a></li><li data-type='method' class="method "><a href="Scene.html#load">load</a></li><li data-type='method' class="method "><a href="Scene.html#newItem">newItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Scene.html#on">on</a></li><li data-type='method' class="method inherits"><a href="Scene.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="Scene.html#play">play</a></li><li data-type='method' class="method "><a href="Scene.html#playCSS">playCSS</a></li><li data-type='method' class="method inherits"><a href="Scene.html#reset">reset</a></li><li data-type='method' class="method "><a href="Scene.html#setItem">setItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="Scene.html#setSelector">setSelector</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Scene.html#trigger">trigger</a></li></ul></li><li><a href="SceneItem.html">SceneItem</a><ul class='methods'><li data-type='method' class="method "><a href="SceneItem.html#clone">clone</a></li><li data-type='method' class="method "><a href="SceneItem.html#copyFrame">copyFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#end">end</a></li><li data-type='method' class="method "><a href="SceneItem.html#fromCSS">fromCSS</a></li><li data-type='method' class="method "><a href="SceneItem.html#getDuration">getDuration</a></li><li data-type='method' class="method "><a href="SceneItem.html#getFrame">getFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#getNowFrame">getNowFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#hasFrame">hasFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#hasOn">hasOn</a></li><li data-type='method' class="method "><a href="SceneItem.html#load">load</a></li><li data-type='method' class="method "><a href="SceneItem.html#mergeFrame">mergeFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#newFrame">newFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#off">off</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#on">on</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#play">play</a></li><li data-type='method' class="method "><a href="SceneItem.html#playCSS">playCSS</a></li><li data-type='method' class="method "><a href="SceneItem.html#removeFrame">removeFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#reset">reset</a></li><li data-type='method' class="method "><a href="SceneItem.html#set">set</a></li><li data-type='method' class="method "><a href="SceneItem.html#setCSS">setCSS</a></li><li data-type='method' class="method "><a href="SceneItem.html#setElement">setElement</a></li><li data-type='method' class="method "><a href="SceneItem.html#setFrame">setFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="SceneItem.html#setSelector">setSelector</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#setTime">setTime</a></li><li data-type='method' class="method "><a href="SceneItem.html#toCSS">toCSS</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#trigger">trigger</a></li><li data-type='method' class="method "><a href="SceneItem.html#update">update</a></li><li data-type='method' class="method "><a href="SceneItem.html#updateFrame">updateFrame</a></li></ul></li><li><a href="Timeline.html">Timeline</a><ul class='methods'><li data-type='method' class="method "><a href="Timeline.html#add">add</a></li><li data-type='method' class="method "><a href="Timeline.html#get">get</a></li><li data-type='method' class="method "><a href="Timeline.html#getLastTime">getLastTime</a></li><li data-type='method' class="method "><a href="Timeline.html#has">has</a></li><li data-type='method' class="method "><a href="Timeline.html#remove">remove</a></li><li data-type='method' class="method "><a href="Timeline.html#size">size</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Animator.html#event:ended">ended</a></li><li><a href="Animator.html#event:paused">paused</a></li><li><a href="Animator.html#event:play">play</a></li><li><a href="Animator.html#event:timeupdate">timeupdate</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">SceneItem.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Animator from "./Animator";
import Frame from "./Frame";
import {
	isUndefined,
	isObject,
	isString,
	isArray,
	isPercent,
	fill,
} from "./utils";
import PropertyObject from "./PropertyObject";
import FrameTimeline from "./FrameTimeline";
import {dotValue} from "./utils/dot";
import {TYPE_PROPERTY_OBJECT, TYPE_ARRAY} from "./consts";


export function getDefaultData(infos, fillText = 0) {
	const {type, size, separator} = infos;

	if (type === TYPE_PROPERTY_OBJECT) {
		return new PropertyObject(fill(new Array(size), fillText), separator);
	} else if (type === TYPE_ARRAY) {
		return fill(new Array(size), fillText);
	} else {
		return fillText;
	}
}
/**
* manage Frame Timeline and play Timeline.
* @extends Animator
*/
class SceneItem extends Animator {
	/**
	* Create a scene's item.
	* @param {Object} properties - properties
	* @example
let item = new Scene.SceneItem({
	0: {
		display: "none",
	},
	1: {
		display: "block",
		opacity: 0,
	},
	2: {
		opacity: 1,
	}
});
	*/
	constructor(properties, options) {
		super();
		this.timeline = new FrameTimeline();
		this.load(properties, options);
	}
	/**
	* Specifies how many seconds an animation takes to complete one cycle
	* Specifies timeline's lastTime
	*/
	getDuration() {
		return Math.max(this.state.duration, this.timeline.getLastTime());
	}
	setDuration(duration) {
		const originalDuration = this.getDuration();
		const ratio = duration / originalDuration;
		const timeline = this.timeline;
		const {times, items} = timeline;
		const obj = {};

		timeline.times = times.map(time => {
			const time2 = time * ratio;

			obj[time2] = items[time];

			return time2;
		});
		timeline.items = obj;
		super.setDuration(duration);
	}
	setId(id) {
		this.options.id = id;
	}
	/**
	* set properties to the sceneItem at that time
	* @param {Number} time - time
	* @param {String|Object} role - property role or properties
	* @param {String|Object} [properties] - property's name or properties
	* @param {Object} [value] - property's value
	* @return {SceneItem} An instance itself
	* @example
item.duration; // = item.timeline.size()
	*/
	set(time, role, properties, value) {
		if (isArray(time)) {
			time.forEach(t => {
				this.set(t, role, properties, value);
			});
			return this;
		} else if (isObject(time)) {
			this.load(time);
			return this;
		}
		const frame = this.getFrame(time) || this.newFrame(time);

		frame.set(role, properties, value);
		this.updateFrame(frame);
		return this;
	}
	get(time, role, properties) {
		const frame = this.getFrame(time);

		return frame &amp;&amp; frame.get(role, properties);
	}
	remove(time, role, properties) {
		const frame = this.getFrame(time);

		frame &amp;&amp; frame.remove(role, properties);
		return this;
	}
	animate(time, parentEasing) {
		const iterationTime = this.getIterationTime();
		const easing = this.getEasing() || parentEasing;
		const frame = this.getNowFrame(iterationTime, easing);

		if (!frame) {
			return frame;
		}
		this.trigger("animate", {
			frame,
			time: iterationTime,
			currentTime: this.getTime(),
		});
		return frame;
	}
	setTime(time, parentEasing) {
		super.setTime(time);

		this.animate(time, parentEasing);
		return this;
	}
	/**
	* update property names used in frames.
	* @return {SceneItem} An instance itself
	* @example
item.update();
	*/
	update() {
		this.timeline.update();
		return this;
	}
	/**
	* update property names used in frame.
	* @param {Number} time - frame's time
	* @param {Frame} [frame] - frame of that time.
	* @return {SceneItem} An instance itself
	* @example
item.updateFrame(time, this.get(time));
	*/
	updateFrame(frame) {
		this.timeline.updateFrame(frame);
		return this;
	}
	/**
	* create and add a frame to the sceneItem at that time
	* @param {Number} time - frame's time
	* @return {Frame} Created frame.
	* @example
item.newFrame(time);
	*/
	newFrame(time) {
		let frame = this.getFrame(time);

		if (frame) {
			return frame;
		}
		frame = new Frame();
		if (!isUndefined(time)) {
			this.setFrame(time, frame);
		}
		return frame;
	}
	/**
	* add a frame to the sceneItem at that time
	* @param {Number} time - frame's time
	* @return {SceneItem} An instance itself
	* @example
item.setFrame(time, frame);
	*/
	setFrame(time, frame) {
		this.timeline.add(time, frame);
		this.timeline.update();
		return this;
	}
	_getTime(time, options = {}) {
		const duration = options.duration || this.getDuration() || 100;

		if (isString(time)) {
			if (isPercent(time)) {
				!this.getDuration() &amp;&amp; (this.state.duration = duration);
				return parseFloat(time) / 100 * duration;
			} else if (time === "from") {
				return 0;
			} else if (time === "to") {
				return duration;
			}
		}
		return parseFloat(time);
	}
	/**
	* get sceneItem's frame at that time
	* @param {Number} time - frame's time
	* @return {Frame} sceneItem's frame at that time
	* @example
const frame = item.getFrame(time);
	*/
	getFrame(time) {
		return this.timeline.get(this._getTime(time));
	}
	/**
	* check if the item has a frame at that time
	* @param {Number} time - frame's time
	* @return {Boolean} true: the item has a frame // false: not
	* @example
if (item.hasFrame(10)) {
	// has
} else {
	// not
}
	*/
	hasFrame(time) {
		return this.timeline.has(time);
	}
	/**
	* remove sceneItem's frame at that time
	* @param {Number} time - frame's time
	* @return {SceneItem} An instance itself
	* @example
item.removeFrame(time);
	*/
	removeFrame(time) {
		const timeline = this.timeline;

		timeline.remove(time);
		timeline.update();

		return this;
	}
	/**
	* Copy frame of the previous time at the next time.
	* @param {Number} fromTime - the previous time
	* @param {Number} toTime - the next time
	* @return {SceneItem} An instance itself
	* @example
// getFrame(0) equal getFrame(1)
item.copyFrame(0, 1);
	*/
	copyFrame(fromTime, toTime) {
		let time;

		if (isObject(fromTime)) {
			for (time in fromTime) {
				this.copyFrame(time, fromTime[time]);
			}
			return this;
		}
		const frame = this.getFrame(fromTime);

		if (!frame) {
			return this;
		}
		const copyFrame = frame.clone();

		this.setFrame(toTime, copyFrame);
		return this;
	}
	/**
	* merge frame of the previous time at the next time.
	* @param {Number} fromTime - the previous time
	* @param {Number} toTime - the next time
	* @return {SceneItem} An instance itself
	* @example
// getFrame(1) contains getFrame(0)
item.merge(0, 1);
	*/
	mergeFrame(fromTime, toTime) {
		let time;

		if (isObject(fromTime)) {
			for (time in fromTime) {
				this.mergeFrame(time, fromTime[time]);
			}
			return this;
		}
		const frame = this.getFrame(fromTime);

		if (!frame) {
			return this;
		}
		const toFrame = this.newFrame(toTime);

		toFrame.merge(frame);
		return this;
	}
	getNowValue(role, property, time, left = this.timeline.size(),
		right = 0, easing = this.state.easing) {
		const timeline = this.timeline;
		const times = timeline.times;
		const length = times.length;


		let prevTime = times[left];
		let nextTime = times[right];
		let prevFrame = timeline.get(prevTime);
		let nextFrame = timeline.get(nextTime);

		if (time >= prevTime) {
			for (let i = left; i >= 0; --i) {
				prevTime = times[i];
				prevFrame = timeline.get(prevTime);
				if (prevFrame.has(role, property)) {
					break;
				}
			}
		}
		for (let i = right; i &lt; length; ++i) {
			nextTime = times[i];
			nextFrame = timeline.get(nextTime);
			if (nextFrame.has(role, property)) {
				break;
			}
		}
		const prevValue = prevFrame &amp;&amp; prevFrame.get(role, property);
		const nextValue = nextFrame &amp;&amp; nextFrame.get(role, property);

		if (isUndefined(prevValue)) {
			return nextValue;
		}
		if (isUndefined(nextValue) || prevValue === nextValue) {
			return prevValue;
		}
		if (prevTime &lt; 0) {
			prevTime = 0;
		}
		const startTime = times[left];
		const endTime = times[right];
		const easingFunction = this.state.easing || easing;

		return dotValue({
			time,
			prevTime,
			nextTime,
			startTime,
			endTime,
			prevValue,
			nextValue,
			easing: easingFunction,
		});
	}
	getNearIndex(time) {
		const timeline = this.timeline;
		const {times} = timeline;
		const last = timeline.getLastTime();
		const length = timeline.size();

		if (length === 0) {
			return undefined;
		}
		// index : length = time : last
		let index = parseInt(last > 0 ? time * length / last : 0, 10);
		let right = length - 1;
		let left = 0;

		if (index &lt; 0) {
			index = 0;
		} else if (index > right) {
			index = right;
		}
		if (time &lt; times[right]) {
			// Binary Search
			while (left &lt; right) {
				if ((left === index || right === index) &amp;&amp; (left + 1 === right)) {
					if (time &lt; times[left]) {
						right = left;
					}
					break;
				} else if (times[index] > time) {
					right = index;
				} else if (times[index] &lt; time) {
					left = index;
				} else {
					right = index;
					left = right;
					break;
				}
				index = parseInt((left + right) / 2, 10);
			}
		} else {
			index = right;
			left = index;
		}

		return {left, right};
	}
	/**
	* Get frame of the current time
	* @param {Number} time - the current time
	* @return {Frame} frame of the current time
	* @example
let item = new Scene.SceneItem({
	0: {
		display: "none",
	},
	1: {
		display: "block",
		opacity: 0,
	},
	2: {
		opacity: 1,
	}
});
// opacity: 0.7; display:"block";
const frame = item.getNowFrame(1.7);
	*/
	getNowFrame(time, easing) {
		const indices = this.getNearIndex(time);

		if (!indices) {
			return indices;
		}
		const {left, right} = indices;
		const frame = this.newFrame();
		const names = this.timeline.names;

		for (const role in names) {
			const propertyNames = names[role];

			for (const property in propertyNames) {
				const value = this.getNowValue(role, property, time, left, right, easing);

				if (isUndefined(value)) {
					continue;
				}
				frame.set(role, property, value);
			}
		}
		return frame;
	}
	/**
	* load properties
	* @param {Object} properties - properties
	* @example
item.load({
	0: {
		display: "none",
	},
	1: {
		display: "block",
		opacity: 0,
	},
	2: {
		opacity: 1,
	}
});
	*/
	load(properties = {}, options = properties.options) {
		this.setOptions(options);
		if (isArray(properties)) {
			const length = properties.length;

			for (let i = 0; i &lt; length; ++i) {
				const time = length === 1 ? 0 : this._getTime(`${i / (length - 1) * 100}%`, options);

				this.set(time, properties[i]);
			}
			return this;
		}
		for (const time in properties) {
			if (time === "options") {
				continue;
			}
			const _properties = properties[time];
			const realTime = this._getTime(time);

			if (typeof _properties === "number") {
				this.mergeFrame(_properties, realTime);
				continue;
			}
			this.set(realTime, properties[time]);
		}
		return this;
	}
	/**
	* clone SceneItem.
	* @return {Scene.SceneItem} An instance of clone
	* @example
	item.clone();
	*/
	clone(options = {}) {
		const item = new this.constructor();
		const times = this.timeline.times;

		item.setOptions(this.state);
		item.setOptions(options);
		times.forEach(time => item.setFrame(time, this.getFrame(time).clone()));

		return item;
	}
}

export default SceneItem;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed May 09 2018 23:53:33 GMT+0900 (KST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
