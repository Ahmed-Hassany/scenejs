<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Animator.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><ul><li><a href="Animator.html">Animator</a><h4><a href="Animator.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Animator.html#end">end</a></li><li data-type='method' class="method inherits"><a href="Animator.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Animator.html#on">on</a></li><li data-type='method' class="method "><a href="Animator.html#pause">pause</a></li><li data-type='method' class="method "><a href="Animator.html#play">play</a></li><li data-type='method' class="method "><a href="Animator.html#reset">reset</a></li><li data-type='method' class="method "><a href="Animator.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="Animator.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Animator.html#trigger">trigger</a></li></ul><h4><a href="Animator.html#events">Events</a></h4><ul class='events'><li data-type='event' class="event"><a href="Animator.html#event:ended">ended</a></li><li data-type='event' class="event"><a href="Animator.html#event:iteration">iteration</a></li><li data-type='event' class="event"><a href="Animator.html#event:paused">paused</a></li><li data-type='event' class="event"><a href="Animator.html#event:play">play</a></li><li data-type='event' class="event"><a href="Animator.html#event:timeupdate">timeupdate</a></li></ul></li><li><a href="EventTrigger.html">EventTrigger</a><h4><a href="EventTrigger.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="EventTrigger.html#off">off</a></li><li data-type='method' class="method "><a href="EventTrigger.html#on">on</a></li><li data-type='method' class="method "><a href="EventTrigger.html#trigger">trigger</a></li></ul></li><li><a href="Frame.html">Frame</a><h4><a href="Frame.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Frame.html#clone">clone</a></li><li data-type='method' class="method "><a href="Frame.html#get">get</a></li><li data-type='method' class="method "><a href="Frame.html#has">has</a></li><li data-type='method' class="method "><a href="Frame.html#load">load</a></li><li data-type='method' class="method "><a href="Frame.html#merge">merge</a></li><li data-type='method' class="method "><a href="Frame.html#remove">remove</a></li><li data-type='method' class="method "><a href="Frame.html#set">set</a></li><li data-type='method' class="method "><a href="Frame.html#toCSS">toCSS</a></li><li data-type='method' class="method "><a href="Frame.html#toCSSObject">toCSSObject</a></li></ul></li><li><a href="PropertyObject.html">PropertyObject</a><h4><a href="PropertyObject.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="PropertyObject.html#clone">clone</a></li><li data-type='method' class="method "><a href="PropertyObject.html#forEach">forEach</a></li><li data-type='method' class="method "><a href="PropertyObject.html#get">get</a></li><li data-type='method' class="method "><a href="PropertyObject.html#join">join</a></li><li data-type='method' class="method "><a href="PropertyObject.html#set">set</a></li><li data-type='method' class="method "><a href="PropertyObject.html#size">size</a></li><li data-type='method' class="method "><a href="PropertyObject.html#toValue">toValue</a></li></ul></li><li><a href="Scene.html">Scene</a><h4><a href="Scene.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method inherits"><a href="Scene.html#end">end</a></li><li data-type='method' class="method "><a href="Scene.html#getDuration">getDuration</a></li><li data-type='method' class="method "><a href="Scene.html#getItem">getItem</a></li><li data-type='method' class="method "><a href="Scene.html#load">load</a></li><li data-type='method' class="method "><a href="Scene.html#newItem">newItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Scene.html#on">on</a></li><li data-type='method' class="method inherits"><a href="Scene.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="Scene.html#play">play</a></li><li data-type='method' class="method "><a href="Scene.html#playCSS">playCSS</a></li><li data-type='method' class="method inherits"><a href="Scene.html#reset">reset</a></li><li data-type='method' class="method "><a href="Scene.html#setItem">setItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="Scene.html#setSelector">setSelector</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Scene.html#trigger">trigger</a></li></ul><h4><a href="Scene.html#events">Events</a></h4><ul class='events'><li data-type='event' class="event"><a href="Scene.html#event:animate">animate</a></li><li data-type='event' class="event"><a href="Scene.html#event:ended">ended</a></li><li data-type='event' class="event"><a href="Scene.html#event:iteration">iteration</a></li><li data-type='event' class="event"><a href="Scene.html#event:paused">paused</a></li><li data-type='event' class="event"><a href="Scene.html#event:play">play</a></li><li data-type='event' class="event"><a href="Scene.html#event:timeupdate">timeupdate</a></li></ul></li><li><a href="SceneItem.html">SceneItem</a><h4><a href="SceneItem.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="SceneItem.html#clone">clone</a></li><li data-type='method' class="method "><a href="SceneItem.html#copyFrame">copyFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#end">end</a></li><li data-type='method' class="method "><a href="SceneItem.html#fromCSS">fromCSS</a></li><li data-type='method' class="method "><a href="SceneItem.html#get">get</a></li><li data-type='method' class="method "><a href="SceneItem.html#getDuration">getDuration</a></li><li data-type='method' class="method "><a href="SceneItem.html#getFrame">getFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#getId">getId</a></li><li data-type='method' class="method "><a href="SceneItem.html#getNowFrame">getNowFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#hasFrame">hasFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#load">load</a></li><li data-type='method' class="method "><a href="SceneItem.html#mergeFrame">mergeFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#newFrame">newFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#off">off</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#on">on</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#play">play</a></li><li data-type='method' class="method "><a href="SceneItem.html#playCSS">playCSS</a></li><li data-type='method' class="method "><a href="SceneItem.html#removeFrame">removeFrame</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#reset">reset</a></li><li data-type='method' class="method "><a href="SceneItem.html#set">set</a></li><li data-type='method' class="method "><a href="SceneItem.html#setCSS">setCSS</a></li><li data-type='method' class="method "><a href="SceneItem.html#setElement">setElement</a></li><li data-type='method' class="method "><a href="SceneItem.html#setFrame">setFrame</a></li><li data-type='method' class="method "><a href="SceneItem.html#setId">setId</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="SceneItem.html#setSelector">setSelector</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#setTime">setTime</a></li><li data-type='method' class="method "><a href="SceneItem.html#toCSS">toCSS</a></li><li data-type='method' class="method inherits"><a href="SceneItem.html#trigger">trigger</a></li><li data-type='method' class="method "><a href="SceneItem.html#update">update</a></li><li data-type='method' class="method "><a href="SceneItem.html#updateFrame">updateFrame</a></li></ul><h4><a href="SceneItem.html#events">Events</a></h4><ul class='events'><li data-type='event' class="event"><a href="SceneItem.html#event:animate">animate</a></li><li data-type='event' class="event"><a href="SceneItem.html#event:ended">ended</a></li><li data-type='event' class="event"><a href="SceneItem.html#event:iteration">iteration</a></li><li data-type='event' class="event"><a href="SceneItem.html#event:paused">paused</a></li><li data-type='event' class="event"><a href="SceneItem.html#event:play">play</a></li><li data-type='event' class="event"><a href="SceneItem.html#event:timeupdate">timeupdate</a></li></ul></li><li><a href="Timeline.html">Timeline</a><h4><a href="Timeline.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Timeline.html#add">add</a></li><li data-type='method' class="method "><a href="Timeline.html#get">get</a></li><li data-type='method' class="method "><a href="Timeline.html#getLastTime">getLastTime</a></li><li data-type='method' class="method "><a href="Timeline.html#has">has</a></li><li data-type='method' class="method "><a href="Timeline.html#remove">remove</a></li><li data-type='method' class="method "><a href="Timeline.html#size">size</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Animator.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import EventTrigger from "./EventTrigger";
import cubicBezier from "./cubicBezier";
import {defineGetter, defineGetterSetter} from "./utils";

let lastTime = 0;

const requestAnimFrame = (function() {
	return window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame	||
		function(callback) {
			const currTime = Date.now();
			const timeToCall = Math.max(0, 16 - (currTime - lastTime));
			const id = window.setTimeout(() => {
				callback(currTime + timeToCall);
			}, 1000 / 60);

			lastTime = currTime + timeToCall;
			return id;
		};
})();

/**
* play video, animation, the others
* @extends EventTrigger
*/
class Animator extends EventTrigger {
	/**
	* Create an Animator.
	* &lt;br/>see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}
	* @param {Object} [options] - animator's options
	* @param {Number} [options.delay] - specifies a delay for the start of an animation
	* @param {String} [options.direction] - Specifies whether an animation should play in reverse direction or alternate cycles
	* @param {Number} [options.duration] - Specifies how many seconds or milliseconds an animation takes to complete one cycle
	* @param {String} [options.fillMode] - Specifies a style for the element when the animation is not playing (when it is finished, or when it has a delay)
	* @param {Number|String} [options.iterationCount] - specifies the number of times an animation should be played
	* @param {Object} [options.easing] - Specifies the speed curve of the animation
	* @example
const animator = new Animator({
	delay: 2,
	diretion: "alternate",
	duration: 2,
	fillMode: "forwards",
	iterationCount: 3,
	easing: Scene.Animator.EASE,
});
	*/
	constructor(options) {
		super();
		this._timer = 0;
		this.options = {};
		this.state = {
			easing: 0,
			easingName: "linear",
			iterationCount: 1,
			delay: 0,
			fillMode: "forwards",
			direction: "normal",
			playSpeed: 1,
			currentTime: 0,
			currentIterationTime: -1,
			currentIterationCount: 0,
			prevTime: 0,
			playState: "paused",
			duration: 0,
		};
		this.setOptions(options);
	}
	setEasing(curveArray) {
		if (Array.isArray(curveArray)) {
			this.state.easingName = `cubic-bezier(${curveArray.join(",")})`;
			this.state.easing = cubicBezier(...curveArray);
		} else {
			this.state.easing = curveArray;
			this.state.easingName = curveArray.easingName || "linear";
		}
		return this;
	}
	/**
	* set animator's options.
	* &lt;br/>see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}
	* @param {Object} [options] - animator's options
	* @param {Number} [options.delay] - specifies a delay for the start of an animation
	* @param {String} [options.direction] - Specifies whether an animation should play in reverse direction or alternate cycles
	* @param {Number} [options.duration] - Specifies how many seconds or milliseconds an animation takes to complete one cycle
	* @param {String} [options.fillMode] - Specifies a style for the element when the animation is not playing (when it is finished, or when it has a delay)
	* @param {Number|String} [options.iterationCount] - specifies the number of times an animation should be played
	* @param {Object} [options.easing] - Specifies the speed curve of the animation
	* @return {Animator} An instance itself.
	* @example
animator.({
	delay: 2,
	diretion: "alternate",
	duration: 2,
	fillMode: "forwards",
	iterationCount: 3,
	easing: Scene.Animator.EASE,
});
	*/
	setOptions(options) {
		if (!options) {
			return this;
		}
		for (const name in options) {
			const value = options[name];

			if (name === "easing") {
				this.setEasing(value);
				continue;
			} else if (name === "duration") {
				value &amp;&amp; this.setDuration(value);
				continue;
			}
			(name in this.state ? this.state : this.options)[name] = value;
		}

		return this;
	}
	setCurrentIterationCount(iterationCount) {
		const passIterationCount = parseInt(iterationCount, 10);

		if (this.state.currentIterationCount &lt; passIterationCount) {
			/**
			* The event is fired when an iteration of an animation ends.
			* @event Animator#iteration
			* @param {Object} param The object of data to be sent to an event.
			* @param {Number} param.currentTime The total time that the animator is running.
			* @param {Number} param.iterationCount The iteration count that the animator is running.
			*/
			this.trigger("iteration", {
				currentTime: this.state.currentTime,
				iterationCount: passIterationCount,
			});
		}
		this.state.currentIterationCount = iterationCount;
	}
	getTotalDuration() {
		if (this.state.iterationCount === "infinite") {
			return Infinity;
		}
		return this.state.delay + this.getActiveDuration();
	}
	getActiveDuration() {
		if (this.state.iterationCount === "infinite") {
			return Infinity;
		}
		return this.getDuration() * this.state.iterationCount;
	}
	isEnded() {
		if (this.getTime() === 0 &amp;&amp; this.state.playState === "paused") {
			return true;
		} else if (this.getTime() &lt; this.getTotalDuration()) {
			return false;
		}
		return true;
	}
	isPaused() {
		return this.state.playState === "paused";
	}
	setNext(animator) {
		this.on("ended", () => {
			animator.play();
		});
		return this;
	}
	/**
	* play animator
	* @return {Animator} An instance itself.
	*/
	play() {
		if (this.isEnded()) {
			this.setTime(0);
		}
		this.state.playState = "running";
		requestAnimFrame(time => {
			this.state.prevTime = time;
			this.tick(time);
		});
		/**
		 * This event is fired when play animator.
		 * @event Animator#play
		 */
		this.trigger("play");

		return this;
	}
	/**
	* pause animator
	* @return {Animator} An instance itself.
	*/
	pause() {
		this.state.playState = "paused";
		/**
		 * This event is fired when animator is paused.
		 * @event Animator#paused
		 */
		this.trigger("paused");
		return this;
	}
	/**
	 * end animator
	 * @return {Animator} An instance itself.
	*/
	end() {
		this.pause();
		/**
		 * This event is fired when animator is ended.
		 * @event Animator#ended
		 */
		this.trigger("ended");
	}
	/**
	* reset animator
	* @return {Animator} An instance itself.
	*/
	reset() {
		this.setTime(0);
		this.pause();
		return this;
	}
	/**
	* set currentTime
	* @param {Number} time - currentTime
	* @return {Animator} An instance itself.
	* @example
animator.setTime(10);

animator.currentTime // 10
	*/
	setTime(time) {
		const totalDuration = this.getTotalDuration();
		let currentTime = time;

		if (currentTime &lt; 0) {
			currentTime = 0;
		} else if (currentTime > totalDuration) {
			currentTime = totalDuration;
		}
		this.state.currentTime = currentTime;
		this.calculateIterationTime();

		/**
		 * This event is fired when the animator updates the time.
		 * @event Animator#timeupdate
		 * @param {Object} param The object of data to be sent to an event.
		 * @param {Number} param.currentTime The total time that the animator is running.
		 * @param {Number} param.time The iteration time during duration that the animator is running.
		 * @param {Number} param.iterationCount The iteration count that the animator is running.
		 */
		this.trigger("timeupdate", {
			currentTime,
			time: this.getIterationTime(),
			iterationCount: this.getIterationCount(),
		});

		return this;
	}
	getTime() {
		return this.state.currentTime;
	}
	getActiveTime() {
		return parseInt(Math.max(this.state.currentTime - this.state.delay, 0) * 10000, 10) / 10000;
	}
	calculateIterationTime() {
		const {iterationCount, fillMode, direction} = this.state;
		const duration = this.getDuration();
		const activeTime = this.getActiveTime();
		const isDelay = this.state.currentTime - this.state.delay &lt; 0;
		const currentIterationCount = duration === 0 ? 0 : activeTime / duration;
		const isOdd = currentIterationCount % 2 >= 1;
		let currentIterationTime = duration ? activeTime % duration : 0;
		let isAlternate = false;

		if (isDelay) {
			this.setIterationTime(0);
			return this;
		}
		this.setCurrentIterationCount(currentIterationCount);
		// direction : normal, reverse, alternate, alternate-reverse
		// fillMode : forwards, backwards, both, none
		switch (direction) {
			case "reverse":
				currentIterationTime = duration - currentIterationTime;
				break;
			case "alternate":
				if (isOdd) {
					currentIterationTime = duration - currentIterationTime;
				}
				isAlternate = true;
				break;
			case "alternate-reverse":
				if (!isOdd) {
					currentIterationTime = duration - currentIterationTime;
				}
				isAlternate = true;
				break;
			default:
		}

		switch (fillMode) {
			case "both":
			case "forwards":
				if (isAlternate || currentIterationCount !== iterationCount || iterationCount % 1 !== 0) {
					break;
				}
				currentIterationTime = duration - currentIterationTime;

				break;
			default:
				if (currentIterationCount !== iterationCount || iterationCount % 1 !== 0) {
					break;
				}
				currentIterationTime = 0;
		}
		this.setIterationTime(currentIterationTime);
		return this;
	}
	caculateEasing(time) {
		if (!this.state.easing) {
			return time;
		}
		const duration = this.getDuration();
		const easing = this.state.easing;
		const ratio = duration === 0 ? 0 : time / duration;
		const easingTime = easing(ratio) * time;

		return easingTime;
	}
	getIterationTime() {
		return this.state.currentIterationTime;
	}
	setIterationTime(time) {
		const iterationTime = time;

		this.state.currentIterationTime = iterationTime;

		return this;
	}
	tick(now) {
		const playSpeed = this.state.playSpeed;
		const prevTime = this.state.prevTime;
		const currentTime = this.getTime() + Math.min(1000, now * playSpeed - prevTime) / 1000;

		this.state.prevTime = now * playSpeed;
		this.setTime(currentTime);
		if (this.isEnded()) {
			this.end();
		}
		if (this.state.playState === "paused") {
			return;
		}

		requestAnimFrame(time => {
			this.tick(time);
		});
	}
}

const AnimatorPrototype = Animator.prototype;

defineGetterSetter(AnimatorPrototype, "delay", "state");
defineGetterSetter(AnimatorPrototype, "fillMode", "state");
defineGetterSetter(AnimatorPrototype, "iterationCount", "state");
defineGetterSetter(AnimatorPrototype, "direction", "state");
defineGetterSetter(AnimatorPrototype, "playState", "state");
defineGetterSetter(AnimatorPrototype, "playSpeed", "state");
defineGetterSetter(AnimatorPrototype, "duration", "state");
defineGetter(AnimatorPrototype, "easingName", "state");
defineGetter(AnimatorPrototype, "easing", "state");


export default Animator;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Jun 20 2018 16:35:14 GMT+0900 (KST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
