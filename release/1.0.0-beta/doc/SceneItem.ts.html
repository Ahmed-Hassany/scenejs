<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SceneItem.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><ul class="classes"><li file="scene"><a href="Scene.html">Scene</a><h4>Members</h4><ul class='members'><li data-type='member'><a href="Scene.html#.VERSION">VERSION</a></li></ul><h4><a href="Scene.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method inherits"><a href="Scene.html#end">end</a></li><li data-type='method' class="method "><a href="Scene.html#exportCSS">exportCSS</a></li><li data-type='method' class="method "><a href="Scene.html#forEach">forEach</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getActiveDuration">getActiveDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getActiveTime">getActiveTime</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getDelay">getDelay</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getDirection">getDirection</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getDuration">getDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getEasing">getEasing</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getEasingName">getEasingName</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getFillMode">getFillMode</a></li><li data-type='method' class="method "><a href="Scene.html#getItem">getItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getIterationCount">getIterationCount</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getIterationTime">getIterationTime</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getPlaySpeed">getPlaySpeed</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getPlayState">getPlayState</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getTime">getTime</a></li><li data-type='method' class="method inherits"><a href="Scene.html#getTotalDuration">getTotalDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.html#isEnded">isEnded</a></li><li data-type='method' class="method inherits"><a href="Scene.html#isPaused">isPaused</a></li><li data-type='method' class="method "><a href="Scene.html#newItem">newItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Scene.html#on">on</a></li><li data-type='method' class="method inherits"><a href="Scene.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="Scene.html#play">play</a></li><li data-type='method' class="method "><a href="Scene.html#playCSS">playCSS</a></li><li data-type='method' class="method inherits"><a href="Scene.html#reset">reset</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setDelay">setDelay</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setDirection">setDirection</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setDuration">setDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setEasing">setEasing</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setFillMode">setFillMode</a></li><li data-type='method' class="method "><a href="Scene.html#setItem">setItem</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setIterationCount">setIterationCount</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setOptions">setOptions</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setPlaySpeed">setPlaySpeed</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setPlayState">setPlayState</a></li><li data-type='method' class="method inherits"><a href="Scene.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Scene.html#trigger">trigger</a></li></ul><h4><a href="Scene.html#events">Events</a></h4><ul class='events'><li data-type='event' class="event"><a href="Scene.html#event:animate">animate</a></li><li data-type='event' class="event"><a href="Scene.html#event:ended">ended</a></li><li data-type='event' class="event"><a href="Scene.html#event:iteration">iteration</a></li><li data-type='event' class="event"><a href="Scene.html#event:paused">paused</a></li><li data-type='event' class="event"><a href="Scene.html#event:play">play</a></li><li data-type='event' class="event"><a href="Scene.html#event:timeupdate">timeupdate</a></li></ul></li><li file="animator"><a href="Scene.Animator.html">Animator</a><h4><a href="Scene.Animator.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.Animator.html#end">end</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getActiveDuration">getActiveDuration</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getActiveTime">getActiveTime</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getDelay">getDelay</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getDirection">getDirection</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getDuration">getDuration</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getEasing">getEasing</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getEasingName">getEasingName</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getFillMode">getFillMode</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getIterationCount">getIterationCount</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getIterationTime">getIterationTime</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getPlaySpeed">getPlaySpeed</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getPlayState">getPlayState</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getTime">getTime</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#getTotalDuration">getTotalDuration</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#isEnded">isEnded</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#isPaused">isPaused</a></li><li data-type='method' class="method inherits"><a href="Scene.Animator.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Scene.Animator.html#on">on</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#pause">pause</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#play">play</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#reset">reset</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setDelay">setDelay</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setDirection">setDirection</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setDuration">setDuration</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setEasing">setEasing</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setFillMode">setFillMode</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setIterationCount">setIterationCount</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setOptions">setOptions</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setPlaySpeed">setPlaySpeed</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setPlayState">setPlayState</a></li><li data-type='method' class="method "><a href="Scene.Animator.html#setTime">setTime</a></li><li data-type='method' class="method inherits"><a href="Scene.Animator.html#trigger">trigger</a></li></ul><h4><a href="Scene.Animator.html#events">Events</a></h4><ul class='events'><li data-type='event' class="event"><a href="Scene.Animator.html#event:ended">ended</a></li><li data-type='event' class="event"><a href="Scene.Animator.html#event:iteration">iteration</a></li><li data-type='event' class="event"><a href="Scene.Animator.html#event:paused">paused</a></li><li data-type='event' class="event"><a href="Scene.Animator.html#event:play">play</a></li><li data-type='event' class="event"><a href="Scene.Animator.html#event:timeupdate">timeupdate</a></li></ul></li><li file="eventtrigger"><a href="Scene.EventTrigger.html">EventTrigger</a><h4><a href="Scene.EventTrigger.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.EventTrigger.html#off">off</a></li><li data-type='method' class="method "><a href="Scene.EventTrigger.html#on">on</a></li><li data-type='method' class="method "><a href="Scene.EventTrigger.html#trigger">trigger</a></li></ul></li><li file="frame"><a href="Scene.Frame.html">Frame</a><h4><a href="Scene.Frame.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.Frame.html#clone">clone</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#get">get</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#has">has</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#merge">merge</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#remove">remove</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#set">set</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#toCSS">toCSS</a></li><li data-type='method' class="method "><a href="Scene.Frame.html#toCSSObject">toCSSObject</a></li></ul></li><li file="propertyobject"><a href="Scene.PropertyObject.html">PropertyObject</a><h4><a href="Scene.PropertyObject.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.PropertyObject.html#clone">clone</a></li><li data-type='method' class="method "><a href="Scene.PropertyObject.html#forEach">forEach</a></li><li data-type='method' class="method "><a href="Scene.PropertyObject.html#get">get</a></li><li data-type='method' class="method "><a href="Scene.PropertyObject.html#join">join</a></li><li data-type='method' class="method "><a href="Scene.PropertyObject.html#set">set</a></li><li data-type='method' class="method "><a href="Scene.PropertyObject.html#size">size</a></li><li data-type='method' class="method "><a href="Scene.PropertyObject.html#toValue">toValue</a></li></ul></li><li file="sceneitem"><a href="Scene.SceneItem.html">SceneItem</a><h4><a href="Scene.SceneItem.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.SceneItem.html#append">append</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#clone">clone</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#copyFrame">copyFrame</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#end">end</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#get">get</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getActiveDuration">getActiveDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getActiveTime">getActiveTime</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getDelay">getDelay</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getDirection">getDirection</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getDuration">getDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getEasing">getEasing</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getEasingName">getEasingName</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getFillMode">getFillMode</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#getFrame">getFrame</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#getId">getId</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getIterationCount">getIterationCount</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getIterationTime">getIterationTime</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#getNowFrame">getNowFrame</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getPlaySpeed">getPlaySpeed</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getPlayState">getPlayState</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getTime">getTime</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#getTotalDuration">getTotalDuration</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#hasFrame">hasFrame</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#isEnded">isEnded</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#isPaused">isPaused</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#mergeFrame">mergeFrame</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#newFrame">newFrame</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#off">off</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#on">on</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#pause">pause</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#play">play</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#playCSS">playCSS</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#prepend">prepend</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#remove">remove</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#removeFrame">removeFrame</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#reset">reset</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#set">set</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#setCSS">setCSS</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setDelay">setDelay</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setDirection">setDirection</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setDuration">setDuration</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setEasing">setEasing</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#setElement">setElement</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setFillMode">setFillMode</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#setFrame">setFrame</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#setId">setId</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setIterationCount">setIterationCount</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setOptions">setOptions</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setPlaySpeed">setPlaySpeed</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setPlayState">setPlayState</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#setSelector">setSelector</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#setTime">setTime</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#toCSS">toCSS</a></li><li data-type='method' class="method inherits"><a href="Scene.SceneItem.html#trigger">trigger</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#update">update</a></li><li data-type='method' class="method "><a href="Scene.SceneItem.html#updateFrame">updateFrame</a></li></ul><h4><a href="Scene.SceneItem.html#events">Events</a></h4><ul class='events'><li data-type='event' class="event"><a href="Scene.SceneItem.html#event:animate">animate</a></li><li data-type='event' class="event"><a href="Scene.SceneItem.html#event:ended">ended</a></li><li data-type='event' class="event"><a href="Scene.SceneItem.html#event:iteration">iteration</a></li><li data-type='event' class="event"><a href="Scene.SceneItem.html#event:paused">paused</a></li><li data-type='event' class="event"><a href="Scene.SceneItem.html#event:play">play</a></li><li data-type='event' class="event"><a href="Scene.SceneItem.html#event:timeupdate">timeupdate</a></li></ul></li></ul><ul class="namespaces"><li file="easing"><a href="Scene.easing.html">easing</a><h4>Members</h4><ul class='members'><li data-type='member'><a href="Scene.easing.html#.EASE">EASE</a></li><li data-type='member'><a href="Scene.easing.html#.EASE_IN">EASE_IN</a></li><li data-type='member'><a href="Scene.easing.html#.EASE_IN_OUT">EASE_IN_OUT</a></li><li data-type='member'><a href="Scene.easing.html#.EASE_OUT">EASE_OUT</a></li><li data-type='member'><a href="Scene.easing.html#.LINEAR">LINEAR</a></li></ul><h4><a href="Scene.easing.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.easing.html#.bezier">bezier</a></li></ul></li><li file="presets"><a href="Scene.presets.html">presets</a><h4><a href="Scene.presets.html#methods">Methods</a></h4><ul class='methods'><li data-type='method' class="method "><a href="Scene.presets.html#.blink">blink</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.fadeIn">fadeIn</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.fadeOut">fadeOut</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.set">set</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.transition">transition</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.wipeIn">wipeIn</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.wipeOut">wipeOut</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.zoomIn">zoomIn</a></li><li data-type='method' class="method "><a href="Scene.presets.html#.zoomOut">zoomOut</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">SceneItem.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Animator, { StateInterface, EasingType, isDirectionReverse } from "./Animator";
import Frame from "./Frame";
import {
	isUndefined,
	isObject,
	isString,
	isArray,
	decamelize,
	splitUnit,
	toFixed,
	isFixed,
} from "./utils";
import Keyframes from "./Keyframes";
import {dotValue} from "./utils/dot";
import {
	KEYFRAMES, ANIMATION, START_ANIMATION, PREFIX, THRESHOLD, ObjectInterface, NameType, timingFunction
} from "./consts";
import {addClass, removeClass, hasClass, fromCSS} from "./utils/css";

function toId(text: string) {
	return text.match(/[0-9a-zA-Z]+/g).join("");
}
function makeId(selector?: boolean) {
	for (;;) {
		const id = `${Math.floor(Math.random() * 100000)}`;

		if (!selector) {
			return id;
		}
		const checkElement = document.querySelector(`[data-scene-id="${id}"]`);

		if (!checkElement) {
			return id;
		}
	}
}
function makeAnimationProperties(properties: ObjectInterface&lt;string | number>) {
	const cssArray = [];

	for (const name in properties) {
		cssArray.push(`${ANIMATION}-${decamelize(name)} : ${properties[name]};`);
	}
	return cssArray.join("");
}

type ElementsType = HTMLElement[] | NodeListOf&lt;HTMLElement>;
/**
* manage Frame Keyframes and play keyframes.
* @memberof Scene
* @extends Scene.Animator
* @example
const item = new Scene.SceneItem({
	0: {
		display: "none",
	},
	1: {
		display: "block",
		opacity: 0,
	},
	2: {
		opacity: 1,
	}
});
*/
class SceneItem extends Animator {
	public keyframes: Keyframes;
	private elements: ElementsType;
	/**
	* @param {Object} [properties] - properties
	* @param {AnimatorOptions} [options] - options
	* @example
	const item = new Scene.SceneItem({
		0: {
			display: "none",
		},
		1: {
			display: "block",
			opacity: 0,
		},
		2: {
			opacity: 1,
		}
	});
	 */
	constructor(properties?: ObjectInterface&lt;any>, options?: ObjectInterface&lt;any>) {
		super();
		this.keyframes = new Keyframes();
		this.elements = [];
		this.load(properties, options);
	}
	public getDuration() {
		return Math.max(this.state.duration, this.keyframes.getDuration());
	}
	public setDuration(duration: number) {
		if (duration === 0) {
			return this;
		}
		const originalDuration = this.getDuration();

		if (originalDuration > 0) {
			this.keyframes.setDuration(duration, originalDuration);
		}
		super.setDuration(toFixed(duration));
		return this;
	}
	/**
	* set the unique indicator of the item.
	* @method Scene.SceneItem#setId
	* @param {String} [id] - the indicator of the item.
	* @return {Scene.SceneItem} An instance itself
	* @example
const item = new SceneItem();

item.setId("item");
console.log(item.getId()); // item
	*/
	public setId(id?: string) {
		const elements = this.elements;
		const length = elements.length;

		this.setState({id: id || makeId(!!length)});
		const sceneId = toId(this.state.id);

		this.options.selector || (this.options.selector = `[data-scene-id="${sceneId}"]`);

		if (!length) {
			return this;
		}
		for (let i = 0; i &lt; length; ++i) {
			elements[i].setAttribute("data-scene-id", sceneId);
		}
		return this;
	}
	/**
	* Specifies the unique indicator of the item.
	* @method Scene.SceneItem#getId
	* @return {String} the indicator of the item.
	* @example
const item = scene.newItem("item");
console.log(item.getId()); // item
	*/
	public getId() {
		return this.state.id;
	}
	/**
	* Set properties to the sceneItem at that time
	* @method Scene.SceneItem#set
	* @param {Number} time - time
	* @param {...String|Object} [properties] - property names or values
	* @return {Scene.SceneItem} An instance itself
	* @example
item.set(0, "a", "b") // item.getFrame(0).set("a", "b")
console.log(item.get(0, "a")); // "b"
	*/
	public set(time: any[] | number | string | ObjectInterface&lt;any>, ...args: any[]) {
		if (isObject(time)) {
			this.load(time);
			return this;
		} else if (args[0]) {
			if (args[0] instanceof SceneItem) {
				const item: SceneItem = args[0];
				const delay = item.getDelay();
				const realTime = this._getTime(time) + delay;
				const {keys, values, frames} = item.getAllTimes(!!delay || !this.hasFrame(time));
				const easing = this.getEasingName() !== item.getEasingName() ? item.getEasing() : 0;

				keys.forEach(t => {
					this.set(realTime + t, frames[values[t]]);
				});
				if (easing) {
					this.set(realTime, timingFunction, easing);
					this.set(realTime + keys[keys.length - 1], timingFunction, "initial");
				}
				return this;
			} else if (args.length === 1 &amp;&amp; isArray(args[0])) {
				args[0].forEach((item: any) => {
					this.set(time, item);
				});
				return this;
			}
		}
		const frame = this.newFrame(time);

		frame.set(...args);
		this.updateFrame(frame);
		return this;
	}
	/**
	* Get properties of the sceneItem at that time
	* @param {Number} time - time
	* @param {...String|Object} args property's name or properties
	* @return {Number|String|Scene.PropertyObejct} property value
	* @example
item.get(0, "a"); // item.getFrame(0).get("a");
item.get(0, "transform", "translate"); // item.getFrame(0).get("transform", "translate");
	*/
	public get(time: number, ...args: NameType[]) {
		const frame = this.getFrame(time);

		return frame &amp;&amp; frame.get(...args);
	}
	/**
	* remove properties to the sceneItem at that time
	* @param {Number} time - time
	* @param {...String|Object} [properties] - property names or values
	* @return {Scene.SceneItem} An instance itself
	* @example
item.remove(0, "a");
	*/
	public remove(time: number, ...args: NameType[]) {
		const frame = this.getFrame(time);

		frame &amp;&amp; frame.remove(...args);
		return this;
	}
	/**
	* Append the item or object at the last time.
	* @param {SceneItem | object} item - the scene item or item object
	* @return {Scene.SceneItem} An instance itself
	* @example
item.append(new SceneItem({
	0: {
		opacity: 0,
	},
	1: {
		opacity: 1,
	}
}));
item.append({
	0: {
		opacity: 0,
	},
	1: {
		opacity: 1,
	}
});
item.set(item.getDuration(), {
	0: {
		opacity: 0,
	},
	1: {
		opacity: 1,
	}
});
	*/
	public append(item: SceneItem | object) {
		this.set(this.getDuration(), item);
		return this;
	}
	/**
	* Push the front frames for the time and prepend the scene item or item object.
	* @param {SceneItem | object} item - the scene item or item object
	* @return {Scene.SceneItem} An instance itself
	*/
	public prepend(item: SceneItem | object) {
		if (item instanceof SceneItem) {
			const delay = item.getDelay();
			const duration = item.getIterationCount() === "infinite" ? item.getDuration() : item.getActiveDuration();
			this.keyframes.unshift(duration + delay);
			this.set(0, item);
		} else {
			this.prepend(new SceneItem(item));
		}
		return this;
	}
	/**
	* Specifies an element to synchronize items' keyframes.
	* @method Scene.SceneItem#setSelector
	* @param {string} selectors - Selectors to find elements in items.
	* @return {Scene.SceneItem} An instance itself
	* @example
item.setSelector("#id.class");
	*/
	public setSelector(selector: boolean | string) {
		this.options.selector = selector === true ? this.state.id :
			(selector || `[data-scene-id="${this.state.id}"]`);
		this.setElement(document.querySelectorAll(this.options.selector));
		return this;
	}
	/**
	* Specifies an element to synchronize item's keyframes.
	* @method Scene.SceneItem#setElement
	* @param {Element|Array|string} elements - elements to synchronize item's keyframes.
	* @return {Scene.SceneItem} An instance itself
	* @example
item.setElement(document.querySelector("#id.class"));
item.setElement(document.querySelectorAll(".class"));
	*/
	public setElement(elements: HTMLElement | ElementsType) {
		if (!elements) {
			return this;
		}
		this.elements = (elements instanceof Element) ? [elements] : elements;
		this.setId();
		return this;
	}
	/**
	* add css styles of items's element to the frame at that time.
	* @method Scene.SceneItem#setCSS
	* @param {Array} properties - elements to synchronize item's keyframes.
	* @return {Scene.SceneItem} An instance itself
	* @example
item.setElement(document.querySelector("#id.class"));
item.setCSS(0, ["opacity"]);
item.setCSS(0, ["opacity", "width", "height"]);
	*/
	public setCSS(time: number, properties: string[]) {
		this.set(time, fromCSS(this.elements, properties));
		return this;
	}
	public setTime(time: number, parentEasing?: EasingType, parent?: any) {
		super.setTime(time);

		this.animate(parentEasing, parent);
		return this;
	}
	/**
	* update property names used in frames.
	* @method Scene.SceneItem#update
	* @return {Scene.SceneItem} An instance itself
	* @example
item.update();
	*/
	public update() {
		this.keyframes.update();
		return this;
	}
	/**
	* update property names used in frame.
	* @method Scene.SceneItem#updateFrame
	* @param {Scene.Frame} [frame] - frame of that time.
	* @return {Scene.SceneItem} An instance itself
	* @example
item.updateFrame(time, this.get(time));
	*/
	public updateFrame(frame: Frame) {
		this.keyframes.updateFrame(frame);
		return this;
	}
	/**
	* Create and add a frame to the sceneItem at that time
	* @method Scene.SceneItem#newFrame
	* @param {Number} time - frame's time
	* @return {Scene.Frame} Created frame.
	* @example
item.newFrame(time);
	*/
	public newFrame(time: string | number) {
		let frame = this.getFrame(time);

		if (frame) {
			return frame;
		}
		frame = new Frame();
		this.setFrame(time, frame);
		return frame;
	}
	/**
	* Add a frame to the sceneItem at that time
	* @method Scene.SceneItem#setFrame
	* @param {Number} time - frame's time
	* @return {Scene.SceneItem} An instance itself
	* @example
item.setFrame(time, frame);
	*/
	public setFrame(time: string | number, frame: Frame) {
		this.keyframes.add(this._getTime(time), frame);
		this.keyframes.update();
		return this;
	}
	/**
	* get sceneItem's frame at that time
	* @method Scene.SceneItem#getFrame
	* @param {Number} time - frame's time
	* @return {Scene.Frame} sceneItem's frame at that time
	* @example
const frame = item.getFrame(time);
	*/
	public getFrame(time: number | string) {
		return this.keyframes.get(this._getTime(time));
	}
	/**
	* check if the item has a frame at that time
	* @method Scene.SceneItem#hasFrame
	* @param {Number} time - frame's time
	* @return {Boolean} true: the item has a frame // false: not
	* @example
if (item.hasFrame(10)) {
	// has
} else {
	// not
}
	*/
	public hasFrame(time: number | string) {
		return this.keyframes.has(this._getTime(time));
	}
	/**
	* remove sceneItem's frame at that time
	* @method Scene.SceneItem#removeFrame
	* @param {Number} time - frame's time
	* @return {Scene.SceneItem} An instance itself
	* @example
item.removeFrame(time);
	*/
	public removeFrame(time: number) {
		const keyframes = this.keyframes;

		keyframes.remove(time);
		keyframes.update();

		return this;
	}
	/**
	* Copy frame of the previous time at the next time.
	* @method Scene.SceneItem#copyFrame
	* @param {number|string|object} fromTime - the previous time
	* @param {number} toTime - the next time
	* @return {Scene.SceneItem} An instance itself
	* @example
// getFrame(0) equal getFrame(1)
item.copyFrame(0, 1);
	*/
	public copyFrame(fromTime: ObjectInterface&lt;number> | number | string, toTime: number) {
		if (isObject(fromTime)) {
			for (const time in fromTime) {
				this.copyFrame(time, fromTime[time]);
			}
			return this;
		}
		const frame = this.getFrame(fromTime);

		if (!frame) {
			return this;
		}
		const copyFrame = frame.clone();

		this.setFrame(toTime, copyFrame);
		return this;
	}
	/**
	* merge frame of the previous time at the next time.
	* @method Scene.SceneItem#mergeFrame
	* @param {number|string|object} fromTime - the previous time
	* @param {number|string} toTime - the next time
	* @return {Scene.SceneItem} An instance itself
	* @example
// getFrame(1) contains getFrame(0)
item.merge(0, 1);
	*/
	public mergeFrame(fromTime: ObjectInterface&lt;number> | number | string, toTime: number | string) {
		if (isObject(fromTime)) {
			for (const time in fromTime) {
				this.mergeFrame(time, fromTime[time]);
			}
			return this;
		}
		const frame = this.getFrame(fromTime);

		if (!frame) {
			return this;
		}
		const toFrame = this.newFrame(toTime);

		toFrame.merge(frame);
		return this;
	}
	/**
	* Get frame of the current time
	* @method Scene.SceneItem#getNowFrame
	* @param {Number} time - the current time
	* @param {function} easing - the speed curve of an animation
	* @return {Scene.Frame} frame of the current time
	* @example
let item = new Scene.SceneItem({
	0: {
		display: "none",
	},
	1: {
		display: "block",
		opacity: 0,
	},
	2: {
		opacity: 1,
	}
});
// opacity: 0.7; display:"block";
const frame = item.getNowFrame(1.7);
	*/
	public getNowFrame(time: number, easing?: EasingType) {
		const frame = new Frame();
		const names = this.keyframes.getNames();
		const {left, right} = this._getNearTimeIndex(time);
		const realEasing = this._getEasing(time, left, right, this.state.easing || easing);

		names.forEach(properties => {
			const value = this._getNowValue(time, left, right, properties, realEasing);

			if (isUndefined(value)) {
				return;
			}
			frame.set(properties, value);
		});
		return frame;
	}
	public load(properties: any = {}, options = properties.options) {
		if (isArray(properties)) {
			const length = properties.length;

			for (let i = 0; i &lt; length; ++i) {
				const time = length === 1 ? 0 : this._getTime(`${i / (length - 1) * 100}%`);

				this.set(time, properties[i]);
			}
		} else if (properties.keyframes) {
			this.set(properties.keyframes);
		} else {
			for (const time in properties) {
				if (time === "options" || time === "keyframes") {
					continue;
				}
				const value = properties[time];
				const realTime = this._getTime(time);

				if (typeof value === "number") {
					this.mergeFrame(value, realTime);
					continue;
				}
				this.set(realTime, value);
			}
		}
		options &amp;&amp; this.setOptions(options);
		return this;
	}
	/**
	 * clone SceneItem.
	 * @method Scene.SceneItem#clone
	 * @param {AnimatorOptions} [options] animator options
	 * @return {Scene.SceneItem} An instance of clone
	 * @example
	 * item.clone();
	 */
	public clone(options = {}) {
		const item = new SceneItem();

		item.setOptions(this.state);
		item.setOptions(options);
		this.keyframes.forEach((frame: Frame, time: number) => item.setFrame(time, frame.clone()));
		return item;
	}
	public setOptions(options: StateInterface = {}) {
		super.setOptions(options);
		const {id, selector, duration, elements} = options;

		duration &amp;&amp; this.setDuration(duration);
		id &amp;&amp; this.setId(id);
		if (elements) {
			this.setElement(elements);
		} else if (selector) {
			this.setSelector(selector === true ? this.state.id : selector);
		}
		return this;
	}
	public getAllTimes(isStartZero = true, options: StateInterface = {}) {
		const times = this.keyframes.times.slice();
		let length = times.length;
		const keys: number[] = [];
		const values: ObjectInterface&lt;number> = {};

		if (!length) {
			return {keys: [], values: {}, frames: {}};
		}
		const frames: ObjectInterface&lt;Frame> = {};
		const duration = this.getDuration();
		const direction = options.direction || this.state.direction;
		const isShuffle = direction === "alternate" || direction === "alternate-reverse";
		(!this.getFrame(0)) &amp;&amp; times.unshift(0);
		(!this.getFrame(duration)) &amp;&amp; times.push(duration);
		length = times.length;
		let iterationCount = options.iterationCount || this.state.iterationCount;

		iterationCount = iterationCount !== "infinite" ? iterationCount : 1;
		const totalDuration = iterationCount * duration;

		for (let i = 0; i &lt; iterationCount; ++i) {
			const isReverse = isDirectionReverse(i, direction);
			const start = i * duration;

			for (let j = 0; j &lt; length; ++j) {
				if (isShuffle &amp;&amp; i !== 0 &amp;&amp; j === 0) {
					// pass duplicate
					continue;
				}
				// isStartZero is keytimes[0] is 0 (i === 0 &amp; j === 0)
				const threshold = j === 0 &amp;&amp; (i === 0 ? !isStartZero : !isShuffle) ? THRESHOLD : 0;
				const keyvalue = isReverse ? times[length - 1 - j] : times[j];
				const time = toFixed(isReverse ? duration - keyvalue : keyvalue);
				const keytime = toFixed(start + time + threshold);

				if (totalDuration &lt; keytime) {
					break;
				}
				keys.push(keytime);
				values[keytime] = keyvalue;

				if (!frames[keyvalue]) {
					const frame = this.getFrame(keyvalue);

					if (j === 0 || j === length - 1 || frame.has("transform") || frame.has("filter")) {
						frames[keyvalue] = this.getNowFrame(keyvalue);
					} else {
						frames[keyvalue] = frame;
					}
				}
			}
		}
		if (keys[keys.length - 1] &lt; totalDuration) {
			// last time === totalDuration
			const isReverse = isDirectionReverse(iterationCount, direction);
			const keyvalue = toFixed(duration * (isReverse ? 1 - iterationCount % 1 : iterationCount % 1));

			keys.push(totalDuration);
			values[totalDuration] = keyvalue;
			!frames[keyvalue] &amp;&amp; (frames[keyvalue] = this.getNowFrame(keyvalue));
		}
		return {keys, values, frames};
	}
	/**
	* Specifies an css text that coverted the keyframes of the item.
	* @param {Array} [duration=this.getDuration()] - elements to synchronize item's keyframes.
	* @param {Array} [options={}] - parent options to unify options of items.
	* @example
item.setCSS(0, ["opacity"]);
item.setCSS(0, ["opacity", "width", "height"]);
	*/
	public toCSS(duration = this.getDuration(), options: StateInterface = {}) {
		const state = this.state;
		const selector = state.selector || this.options.selector;

		if (!selector) {
			return "";
		}
		const id = this._getId();
		const isZeroDuration = duration === 0;
		const playSpeed = (options.playSpeed || 1);
		const delay = ((typeof options.delay === "undefined" ? state.delay : options.delay) || 0) / playSpeed;
		const easingName = (!isZeroDuration &amp;&amp; options.easing &amp;&amp; options.easingName) || state.easingName;
		const count = (!isZeroDuration &amp;&amp; options.iterationCount) || state.iterationCount;
		const fillMode = (options.fillMode !== "forwards" &amp;&amp; options.fillMode) || state.fillMode;
		const direction = (options.direction !== "normal" &amp;&amp; options.direction) || state.direction;
		const cssText = makeAnimationProperties({
			fillMode,
			direction,
			delay: `${delay}s`,
			name: `${PREFIX}KEYFRAMES_${toId(id)}`,
			duration: `${duration / playSpeed}s`,
			timingFunction: easingName,
			iterationCount: count,
		});

		const css = `${selector}.${START_ANIMATION} {
			${cssText}
		}
		${this._toKeyframes(duration, options)}`;

		return css;
	}
	public exportCSS(duration = this.getDuration(), options: StateInterface = {}) {
		if (!this.elements.length) {
			return;
		}
		const id = this._getId();
		const styleElement: HTMLElement = document.querySelector(`#${PREFIX}${id}`);
		const css = this.toCSS(duration, options);

		if (styleElement) {
			styleElement.innerText = css;
		} else {
			document.body.insertAdjacentHTML("beforeend",
				`&lt;style id="${PREFIX}STYLE_${id}">${css}&lt;/style>`);
		}
	}
	/**
	* Play using the css animation and keyframes.
	* @param {boolean} [exportCSS=true] Check if you want to export css.
	* @param {Object} [properties={}] The shorthand properties for six of the animation properties.
	* @param {Object} [properties.duration] The duration property defines how long an animation should take to complete one cycle.
	* @param {Object} [properties.fillMode] The fillMode property specifies a style for the element when the animation is not playing (before it starts, after it ends, or both).
	* @param {Object} [properties.iterationCount] The iterationCount property specifies the number of times an animation should be played.
	* @param {String} [properties.easing] The easing(timing-function) specifies the speed curve of an animation.
	* @param {Object} [properties.delay] The delay property specifies a delay for the start of an animation.
	* @param {Object} [properties.direction] The direction property defines whether an animation should be played forwards, backwards or in alternate cycles.
	* @see {@link https://www.w3schools.com/cssref/css3_pr_animation.asp}
	* @example
item.playCSS();
item.playCSS(false, {
	direction: "reverse",
	fillMode: "forwards",
});
	*/
	public playCSS(exportCSS = true, properties = {}) {
		if (!ANIMATION || this.getPlayState() === "running") {
			return this;
		}
		const elements = this.elements;
		const length = elements.length;

		if (!length) {
			return this;
		}
		if (this.isEnded()) {
			this.setTime(0);
		}
		exportCSS &amp;&amp; this.exportCSS();

		const cssText = makeAnimationProperties(properties);

		for (let i = 0; i &lt; length; ++i) {
			const element = elements[i];

			element.style.cssText += cssText;
			if (hasClass(element, START_ANIMATION)) {
				removeClass(element, START_ANIMATION);
				(el => {
					requestAnimationFrame(() => {
						requestAnimationFrame(() => {
							addClass(el, START_ANIMATION);
						});
					});
				})(element);
			} else {
				addClass(element, START_ANIMATION);
			}
		}

		this.setState({playCSS: true});
		this.setPlayState("running");
		this.trigger("play");

		const duration = this.getDuration();
		const animatedElement = elements[0];
		const animationend = () => {
			this.end();

			if (!animatedElement) {
				return;
			}
			animatedElement.removeEventListener("animationend", animationend);
			animatedElement.removeEventListener("animationiteration", animationiteration);
		};
		const animationiteration = ({elapsedTime}: any) => {
			const currentTime = elapsedTime;
			const iterationCount = currentTime / duration;

			this.state.currentTime = currentTime;
			this.setCurrentIterationCount(iterationCount);
		};
		animatedElement.addEventListener("animationend", animationend);
		animatedElement.addEventListener("animationiteration", animationiteration);
		return this;
	}
	protected animate(parentEasing: EasingType, parent: any) {
		const iterationTime = this.getIterationTime();
		const easing = this.getEasing() || parentEasing;
		const frame = this.getNowFrame(iterationTime, easing);
		const currentTime = this.getTime();

		/**
		 * This event is fired when timeupdate and animate.
		 * @event Scene.SceneItem#animate
		 * @param {Number} param.currentTime The total time that the animator is running.
		 * @param {Number} param.time The iteration time during duration that the animator is running.
		 * @param {Scene.Frame} param.frame frame of that time.
		 */
		this.trigger("animate", {
			frame,
			currentTime,
			time: iterationTime,
		});

		parent &amp;&amp; parent.trigger("animate", {
			frame,
			currentTime,
			target: this,
			time: iterationTime,
		});
		const elements = this.elements;
		const length = elements.length;

		if (!length) {
			return frame;
		}
		const attributes = frame.get("attribute");

		if (attributes) {
			for (const name in (attributes as any)) {
				for (let i = 0; i &lt; length; ++i) {
					elements[i].setAttribute(name, attributes[name]);
				}
			}
		}
		const cssText = frame.toCSS();

		if (this.state.cssText !== cssText) {
			this.state.cssText = cssText;

			for (let i = 0; i &lt; length; ++i) {
				elements[i].style.cssText += cssText;
			}
			return frame;
		}
	}
	private _getId() {
		return this.state.id || this.setId().getId();
	}
	private _getEasing(time: number, left: number, right: number, easing: EasingType) {
		if (this.keyframes.hasName(timingFunction)) {
			const nowEasing = this._getNowValue(time, left, right, [timingFunction], 0, true);

			return typeof nowEasing === "function" ? nowEasing : easing;
		}
		return easing;
	}
	private _getTime(time: string | number) {
		const duration = this.getDuration() || 100;

		if (isString(time)) {
			if (time === "from") {
				return 0;
			} else if (time === "to") {
				return duration;
			}
			const {unit, value} = splitUnit(time);

			if (unit === "%") {
				!this.getDuration() &amp;&amp; (this.state.duration = duration);
				return parseFloat(time) / 100 * duration;
			} else if (unit === ">") {
				return value + THRESHOLD;
			} else {
				return value;
			}
		} else {
			return toFixed(time);
		}
	}
	private _toKeyframes(duration = this.getDuration(), options: StateInterface = {}) {
		const id = this._getId();
		const state = this.state;
		const playSpeed = state.playSpeed;
		const isParent = typeof options.iterationCount !== "undefined";
		const iterationCount =  state.iterationCount;
		const delay = isParent ? state.delay : 0;
		const direction = isParent ? state.direction : "normal";
		const {keys, values, frames} = this.getAllTimes(true, {
			duration,
			delay,
			direction,
			iterationCount: isParent &amp;&amp; iterationCount !== "infinite" ? iterationCount : 1,
			isCSS: true,
		});
		const length = keys.length;
		const css: ObjectInterface&lt;string> = {};
		const keyframes: string[] = [];

		for (const time in frames) {
			css[time] = frames[time].toCSS();
		}
		if (!keys.length) {
			return "";
		}
		if (delay) {
			keyframes.push(`0%{${frames[0]}}`);
			if (direction === "reverse" || direction === "alternate-reverse") {
				keyframes.push(`${delay / playSpeed / duration * 100 - 0.00001}%{${css[0]}}`);
			}
		}
		keys.forEach(time => {
			keyframes.push(`${(delay + time)  / playSpeed / duration * 100}%{${css[values[time]]}}`);
		});
		const lastTime = keys[length - 1];

		if ((delay + lastTime) / playSpeed &lt; duration) {
			// not 100%
			keyframes.push(`100%{${css[values[lastTime]]}`);
		}
		return `@${KEYFRAMES} ${PREFIX}KEYFRAMES_${toId(id)}{
			${keyframes.join("\n")}
		}`;
	}
	private _getNowValue(
		time: number,
		left: number,
		right: number,
		properties: string[],
		easing: EasingType = this.state.easing,
		usePrevValue: boolean = isFixed(properties),
	) {
		const keyframes = this.keyframes;
		const times = keyframes.times;
		const length = times.length;

		let prevTime;
		let nextTime;
		let prevFrame;
		let nextFrame;

		for (let i = left; i >= 0; --i) {
			const frame = keyframes.get(times[i]);

			if (frame.has(...properties)) {
				prevTime = times[i];
				prevFrame = frame;
				break;
			}
		}
		const prevValue = prevFrame &amp;&amp; prevFrame.raw(...properties);

		if (usePrevValue) {
			return prevValue;
		}
		for (let i = right; i &lt; length; ++i) {
			const frame = keyframes.get(times[i]);

			if (frame.has(...properties)) {
				nextTime = times[i];
				nextFrame = frame;
				break;
			}
		}
		const nextValue = nextFrame &amp;&amp; nextFrame.raw(...properties);

		if (!prevFrame || isUndefined(prevValue)) {
			return nextValue;
		}
		if (!nextFrame || isUndefined(nextValue) || prevValue === nextValue) {
			return prevValue;
		}
		if (prevTime &lt; 0) {
			prevTime = 0;
		}
		return dotValue(time, prevTime,	nextTime, prevValue, nextValue,	easing);
	}
	private _getNearTimeIndex(time: number) {
		const keyframes = this.keyframes;
		const times = keyframes.times;
		const length = times.length;

		for (let i = 0; i &lt; length; ++i) {
			if (times[i] === time) {
				return {left: i, right: i};
			} else if (times[i] > time) {
				return {left: i === 0 ? 0 : i - 1, right: i};
			}
		}
		return {left: length - 1, right: length - 1};
	}
}

export default SceneItem;
</code></pre>
        </article>
    </section>





<style>


nav li[file="sceneitem"]:after {
    display: none;
}
nav li[file="sceneitem"] h4, nav li[file="sceneitem"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 0.1.2</a> on Thu Aug 23 2018 17:54:35 GMT+0900 (KST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
